<html>
<head>
  <meta charset="utf-8">
  <title>Crunch - Examples - Factorial Web Worker</title>

  <script src="../crunch.js" type="text/javascript"></script>

  <style>
  	fieldset {
  		margin: 15px;
  		border: none;
  	}

    ol {
      font-family: mono;
      font-size: 0.85em;
      margin-top: 30px;
    }

    ol>li {
      margin-bottom: 4px;
    }
  </style>
</head>
<body>

<h1>Crunch Factorial Example</h1>
<p>In mathematics, the factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. For example: 5! = 5  x  4  x  3  x  2  x  1 = 120</p>

<fieldset>
  <h2>Calculate Factorial via Web Worker</h2>
  <p>Crunch is loaded as a web worker, <em>new Worker("crunch.js")</em>. Every calculation is requested with a message: <em>worker.postMessage({"func": "mul", "args": [iteration, result]})</em>.</p>
  <p>You can chose between the iterative and native implementation. The iterative will return a result at each step, and is slower as decimal conversions are done each time, or the native, which calculates the final result internally and returns it once done.</p>
  <input type="text" name="factorial" id="factorial" value="50">
  <button onclick="calcFactorial()" id="calc-factorial">! Iterative</button>
  <button onclick="calcFactorialNative()" id="calc-factorial-native">! Native</button>
  <ol id="worker-result"></ol>
  <p><em>Note:</em> In the iterative example, a lot of time is wasted in the decimal to byte-array conversion stage, which occurs between every calculation to display the result. This is obvious when comparing, for example, 500! via the two methods.</p>
</fieldset>

<p><a href="./">&laquo; Back to Examples</a></p>

<script>
  var worker = new Worker("../crunch.js"),
      native = new Worker("../crunch.js"),
      result, 
      iteration,
      factorial;

  native.onmessage = function (e) {
    document.getElementById("worker-result").insertAdjacentHTML("beforeend", "<li>" + convert(e.data) + "</li>");
    document.getElementById("calc-factorial-native").disabled = false;
  }

  function calcFactorialNative() {
    document.getElementById("worker-result").innerHTML = "";
    document.getElementById("calc-factorial-native").disabled = true;
    native.postMessage({"func": "factorial", "args": [document.getElementById("factorial").value.toString(10)]});
  }


  worker.onmessage = function (e) {
    result = e.data;
    document.getElementById("worker-result").insertAdjacentHTML("beforeend", "<li>" + convert(result) + "</li>");
    window.scrollTo(0, document.body.offsetHeight);

    if (iteration <= factorial) {
      sendIteration();
    } else {
      document.getElementById("calc-factorial").disabled = false;
    }
  }

  function sendIteration() {
    worker.postMessage({"func": "mul", "args": [convert(iteration.toString(10)), result]});
    iteration++;
  }

  function calcFactorial() {
    result = [1];
    iteration = 1;
    factorial = document.getElementById("factorial").value;
    document.getElementById("worker-result").innerHTML = "";
    document.getElementById("calc-factorial").disabled = true;
    sendIteration();
  }

  //Modified from http://danvk.org/hex2dec.html
  function convert(input) {
    function add(x, y, base) {
      var z = [],
          n = Math.max(x.length, y.length),
          c = 0,
          i = -1,
          xi, yi, zi;

      while (++i < n || c) {
        xi = i < x.length ? x[i] : 0;
        yi = i < y.length ? y[i] : 0;
        zi = c + xi + yi;

        z.push(zi % base);
        c = Math.floor(zi / base);
      }

      return z;
    }

    function multiply(num, x, base) {
      var result = [],
          power = x;

      if (num != 0) {
        while (true) {
          if (num & 1)
            result = add(result, power, base);

          num = num >> 1;

          if (num === 0)
            break;

          power = add(power, power, base);
        }
      }

      return result;
    }

    function convertBase(str, fromBase, toBase) {
      var digits = str.split('').map(function(v) { return parseInt(v, fromBase) }).reverse(),
          result = [],
          power = [1],
          i;

      for (i = 0; i < digits.length; i++) {
        if (digits[i]) {
          result = add(result, multiply(digits[i], power, toBase), toBase);
        }
        power = multiply(fromBase, power, toBase);
      }

      return result.reverse().map(function(v) { return v.toString(toBase) }).join("");
    }

    if (Array.isArray(input)) {
      return convertBase(input.map(function(v) { return ("0"+v.toString(16)).slice(-2) }).join(""), 16, 10);
    } else {
      var hexStr = convertBase(input, 10, 16);

      if (hexStr.length % 2) 
        hexStr = "0" + hexStr;

      return hexStr.match(/.{2}/g).map(function(v) { return parseInt(v, 16) });
    }
  }
</script>

</body>
</html>